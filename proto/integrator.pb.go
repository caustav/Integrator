// Code generated by protoc-gen-go.
// source: integrator.proto
// DO NOT EDIT!

/*
Package integrator is a generated protocol buffer package.

It is generated from these files:
	integrator.proto

It has these top-level messages:
	Module
	RegisterResponse
	StartRequest
	StartResponse
	Component
	DataType
	SaveChainRequest
	SaveChainResponse
	ExecuteRequest
	ExecuteResponse
*/
package integrator

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DataType_Type int32

const (
	DataType_INT   DataType_Type = 0
	DataType_STR   DataType_Type = 1
	DataType_BOOL  DataType_Type = 2
	DataType_BYTES DataType_Type = 3
)

var DataType_Type_name = map[int32]string{
	0: "INT",
	1: "STR",
	2: "BOOL",
	3: "BYTES",
}
var DataType_Type_value = map[string]int32{
	"INT":   0,
	"STR":   1,
	"BOOL":  2,
	"BYTES": 3,
}

func (x DataType_Type) String() string {
	return proto.EnumName(DataType_Type_name, int32(x))
}
func (DataType_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Module struct {
	ModuleId   string       `protobuf:"bytes,1,opt,name=moduleId" json:"moduleId,omitempty"`
	Url        string       `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	Components []*Component `protobuf:"bytes,3,rep,name=components" json:"components,omitempty"`
}

func (m *Module) Reset()                    { *m = Module{} }
func (m *Module) String() string            { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()               {}
func (*Module) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Module) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *Module) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Module) GetComponents() []*Component {
	if m != nil {
		return m.Components
	}
	return nil
}

type RegisterResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *RegisterResponse) Reset()                    { *m = RegisterResponse{} }
func (m *RegisterResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterResponse) ProtoMessage()               {}
func (*RegisterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RegisterResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type StartRequest struct {
	ChainId        string     `protobuf:"bytes,1,opt,name=chainId" json:"chainId,omitempty"`
	StartComponent *Component `protobuf:"bytes,2,opt,name=startComponent" json:"startComponent,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StartRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *StartRequest) GetStartComponent() *Component {
	if m != nil {
		return m.StartComponent
	}
	return nil
}

type StartResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *StartResponse) Reset()                    { *m = StartResponse{} }
func (m *StartResponse) String() string            { return proto.CompactTextString(m) }
func (*StartResponse) ProtoMessage()               {}
func (*StartResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StartResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type Component struct {
	Name         string               `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	ParamsInput  map[string]*DataType `protobuf:"bytes,2,rep,name=paramsInput" json:"paramsInput,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ParamsOutput map[string]*DataType `protobuf:"bytes,3,rep,name=paramsOutput" json:"paramsOutput,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Component) Reset()                    { *m = Component{} }
func (m *Component) String() string            { return proto.CompactTextString(m) }
func (*Component) ProtoMessage()               {}
func (*Component) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Component) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Component) GetParamsInput() map[string]*DataType {
	if m != nil {
		return m.ParamsInput
	}
	return nil
}

func (m *Component) GetParamsOutput() map[string]*DataType {
	if m != nil {
		return m.ParamsOutput
	}
	return nil
}

type DataType struct {
	Str     string        `protobuf:"bytes,1,opt,name=str" json:"str,omitempty"`
	Int     int32         `protobuf:"varint,2,opt,name=int" json:"int,omitempty"`
	Boolean bool          `protobuf:"varint,3,opt,name=boolean" json:"boolean,omitempty"`
	Byteall []byte        `protobuf:"bytes,4,opt,name=byteall,proto3" json:"byteall,omitempty"`
	Type    DataType_Type `protobuf:"varint,5,opt,name=type,enum=integrator.DataType_Type" json:"type,omitempty"`
}

func (m *DataType) Reset()                    { *m = DataType{} }
func (m *DataType) String() string            { return proto.CompactTextString(m) }
func (*DataType) ProtoMessage()               {}
func (*DataType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DataType) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

func (m *DataType) GetInt() int32 {
	if m != nil {
		return m.Int
	}
	return 0
}

func (m *DataType) GetBoolean() bool {
	if m != nil {
		return m.Boolean
	}
	return false
}

func (m *DataType) GetByteall() []byte {
	if m != nil {
		return m.Byteall
	}
	return nil
}

func (m *DataType) GetType() DataType_Type {
	if m != nil {
		return m.Type
	}
	return DataType_INT
}

type SaveChainRequest struct {
	ChainInfo []byte `protobuf:"bytes,2,opt,name=chainInfo,proto3" json:"chainInfo,omitempty"`
}

func (m *SaveChainRequest) Reset()                    { *m = SaveChainRequest{} }
func (m *SaveChainRequest) String() string            { return proto.CompactTextString(m) }
func (*SaveChainRequest) ProtoMessage()               {}
func (*SaveChainRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SaveChainRequest) GetChainInfo() []byte {
	if m != nil {
		return m.ChainInfo
	}
	return nil
}

type SaveChainResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *SaveChainResponse) Reset()                    { *m = SaveChainResponse{} }
func (m *SaveChainResponse) String() string            { return proto.CompactTextString(m) }
func (*SaveChainResponse) ProtoMessage()               {}
func (*SaveChainResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SaveChainResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type ExecuteRequest struct {
	Component *Component `protobuf:"bytes,1,opt,name=component" json:"component,omitempty"`
}

func (m *ExecuteRequest) Reset()                    { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()               {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExecuteRequest) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

type ExecuteResponse struct {
}

func (m *ExecuteResponse) Reset()                    { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()               {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func init() {
	proto.RegisterType((*Module)(nil), "integrator.Module")
	proto.RegisterType((*RegisterResponse)(nil), "integrator.RegisterResponse")
	proto.RegisterType((*StartRequest)(nil), "integrator.StartRequest")
	proto.RegisterType((*StartResponse)(nil), "integrator.StartResponse")
	proto.RegisterType((*Component)(nil), "integrator.Component")
	proto.RegisterType((*DataType)(nil), "integrator.DataType")
	proto.RegisterType((*SaveChainRequest)(nil), "integrator.SaveChainRequest")
	proto.RegisterType((*SaveChainResponse)(nil), "integrator.SaveChainResponse")
	proto.RegisterType((*ExecuteRequest)(nil), "integrator.ExecuteRequest")
	proto.RegisterType((*ExecuteResponse)(nil), "integrator.ExecuteResponse")
	proto.RegisterEnum("integrator.DataType_Type", DataType_Type_name, DataType_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Integrator service

type IntegratorClient interface {
	Register(ctx context.Context, in *Module, opts ...grpc.CallOption) (*RegisterResponse, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	SaveChain(ctx context.Context, in *SaveChainRequest, opts ...grpc.CallOption) (*SaveChainResponse, error)
}

type integratorClient struct {
	cc *grpc.ClientConn
}

func NewIntegratorClient(cc *grpc.ClientConn) IntegratorClient {
	return &integratorClient{cc}
}

func (c *integratorClient) Register(ctx context.Context, in *Module, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := grpc.Invoke(ctx, "/integrator.Integrator/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integratorClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	out := new(StartResponse)
	err := grpc.Invoke(ctx, "/integrator.Integrator/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integratorClient) SaveChain(ctx context.Context, in *SaveChainRequest, opts ...grpc.CallOption) (*SaveChainResponse, error) {
	out := new(SaveChainResponse)
	err := grpc.Invoke(ctx, "/integrator.Integrator/SaveChain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Integrator service

type IntegratorServer interface {
	Register(context.Context, *Module) (*RegisterResponse, error)
	Start(context.Context, *StartRequest) (*StartResponse, error)
	SaveChain(context.Context, *SaveChainRequest) (*SaveChainResponse, error)
}

func RegisterIntegratorServer(s *grpc.Server, srv IntegratorServer) {
	s.RegisterService(&_Integrator_serviceDesc, srv)
}

func _Integrator_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegratorServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/integrator.Integrator/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegratorServer).Register(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrator_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegratorServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/integrator.Integrator/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegratorServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrator_SaveChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegratorServer).SaveChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/integrator.Integrator/SaveChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegratorServer).SaveChain(ctx, req.(*SaveChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Integrator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "integrator.Integrator",
	HandlerType: (*IntegratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Integrator_Register_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Integrator_Start_Handler,
		},
		{
			MethodName: "SaveChain",
			Handler:    _Integrator_SaveChain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integrator.proto",
}

// Client API for IntegratorModule service

type IntegratorModuleClient interface {
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
}

type integratorModuleClient struct {
	cc *grpc.ClientConn
}

func NewIntegratorModuleClient(cc *grpc.ClientConn) IntegratorModuleClient {
	return &integratorModuleClient{cc}
}

func (c *integratorModuleClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	out := new(ExecuteResponse)
	err := grpc.Invoke(ctx, "/integrator.IntegratorModule/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IntegratorModule service

type IntegratorModuleServer interface {
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
}

func RegisterIntegratorModuleServer(s *grpc.Server, srv IntegratorModuleServer) {
	s.RegisterService(&_IntegratorModule_serviceDesc, srv)
}

func _IntegratorModule_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegratorModuleServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/integrator.IntegratorModule/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegratorModuleServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IntegratorModule_serviceDesc = grpc.ServiceDesc{
	ServiceName: "integrator.IntegratorModule",
	HandlerType: (*IntegratorModuleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _IntegratorModule_Execute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "integrator.proto",
}

func init() { proto.RegisterFile("integrator.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xad, 0xe3, 0xa4, 0x8d, 0xa7, 0x21, 0x75, 0x56, 0x20, 0xb9, 0xa6, 0x48, 0x91, 0x0f, 0x25,
	0x20, 0x62, 0xa1, 0x54, 0x48, 0x08, 0x89, 0x1e, 0xd2, 0x46, 0x22, 0x7c, 0x25, 0xda, 0x04, 0x09,
	0x8e, 0x5b, 0x77, 0x09, 0x56, 0x9d, 0xb5, 0xf1, 0xae, 0x2b, 0xf2, 0xef, 0xf8, 0x19, 0xdc, 0xf9,
	0x23, 0x68, 0xd7, 0x9f, 0x09, 0x09, 0x3d, 0x70, 0x9b, 0x99, 0x7d, 0xf3, 0xde, 0xf3, 0x78, 0x67,
	0xc1, 0xf4, 0x99, 0xa0, 0x8b, 0x98, 0x88, 0x30, 0x76, 0xa3, 0x38, 0x14, 0x21, 0x82, 0xb2, 0xe2,
	0x2c, 0x61, 0xff, 0x43, 0x78, 0x9d, 0x04, 0x14, 0xd9, 0xd0, 0x5c, 0xaa, 0x68, 0x7c, 0x6d, 0x69,
	0x5d, 0xad, 0x67, 0xe0, 0x22, 0x47, 0x26, 0xe8, 0x49, 0x1c, 0x58, 0x35, 0x55, 0x96, 0x21, 0x7a,
	0x01, 0xe0, 0x85, 0xcb, 0x28, 0x64, 0x94, 0x09, 0x6e, 0xe9, 0x5d, 0xbd, 0x77, 0x38, 0x78, 0xe0,
	0x56, 0xa4, 0x2e, 0xf2, 0x53, 0x5c, 0x01, 0x3a, 0xcf, 0xc0, 0xc4, 0x74, 0xe1, 0x73, 0x41, 0x63,
	0x4c, 0x79, 0x14, 0x32, 0x4e, 0x91, 0x05, 0x07, 0x3c, 0xf1, 0x3c, 0xca, 0xb9, 0xd2, 0x6d, 0xe2,
	0x3c, 0x75, 0x16, 0xd0, 0x9a, 0x09, 0x12, 0x0b, 0x4c, 0xbf, 0x27, 0x94, 0x0b, 0x89, 0xf4, 0xbe,
	0x11, 0x9f, 0x15, 0x0e, 0xf3, 0x14, 0xbd, 0x86, 0x36, 0x97, 0xc8, 0x42, 0x55, 0x79, 0xdd, 0x69,
	0x69, 0x03, 0xec, 0x3c, 0x81, 0x7b, 0x99, 0xd0, 0x9d, 0x9e, 0x7e, 0xd7, 0xc0, 0x28, 0x1a, 0x11,
	0x82, 0x3a, 0x23, 0x4b, 0x9a, 0xd9, 0x51, 0x31, 0x7a, 0x03, 0x87, 0x11, 0x89, 0xc9, 0x92, 0x8f,
	0x59, 0x94, 0x48, 0x23, 0x72, 0x36, 0xa7, 0x5b, 0x8d, 0xb8, 0xd3, 0x12, 0x38, 0x62, 0x22, 0x5e,
	0xe1, 0x6a, 0x2b, 0x7a, 0x07, 0xad, 0x34, 0x9d, 0x24, 0x42, 0x52, 0xa5, 0x63, 0x7e, 0xfc, 0x2f,
	0xaa, 0x14, 0x99, 0x72, 0xad, 0x35, 0xdb, 0x73, 0x30, 0x37, 0xd5, 0xe4, 0x7f, 0xbd, 0xa1, 0xab,
	0xcc, 0xbd, 0x0c, 0xd1, 0x53, 0x68, 0xdc, 0x92, 0x20, 0xa1, 0xd9, 0xfc, 0xee, 0x57, 0xb5, 0x2e,
	0x89, 0x20, 0xf3, 0x55, 0x44, 0x71, 0x0a, 0x79, 0x55, 0x7b, 0xa9, 0xd9, 0x9f, 0xa0, 0xf3, 0x97,
	0xf0, 0xff, 0xd3, 0x3a, 0x3f, 0x35, 0x68, 0xe6, 0x75, 0x49, 0xc7, 0x45, 0x9c, 0xd3, 0x71, 0x11,
	0xcb, 0x8a, 0x9f, 0xfd, 0xe3, 0x06, 0x96, 0xa1, 0xfc, 0x61, 0x57, 0x61, 0x18, 0x50, 0xc2, 0x2c,
	0x3d, 0xfd, 0x61, 0x59, 0xaa, 0x4e, 0x56, 0x82, 0x92, 0x20, 0xb0, 0xea, 0x5d, 0xad, 0xd7, 0xc2,
	0x79, 0x8a, 0xfa, 0x50, 0x17, 0xab, 0x88, 0x5a, 0x8d, 0xae, 0xd6, 0x6b, 0x0f, 0x8e, 0xb7, 0x79,
	0x72, 0x95, 0x31, 0x05, 0x73, 0xfa, 0x50, 0x57, 0x76, 0x0e, 0x40, 0x1f, 0x7f, 0x9c, 0x9b, 0x7b,
	0x32, 0x98, 0xcd, 0xb1, 0xa9, 0xa1, 0x26, 0xd4, 0x87, 0x93, 0xc9, 0x7b, 0xb3, 0x86, 0x0c, 0x68,
	0x0c, 0xbf, 0xcc, 0x47, 0x33, 0x53, 0x77, 0x9e, 0x83, 0x39, 0x23, 0xb7, 0xf4, 0x42, 0xde, 0xd0,
	0xfc, 0x02, 0x9f, 0x80, 0x91, 0xde, 0x58, 0xf6, 0x35, 0x54, 0xee, 0x5b, 0xb8, 0x2c, 0x38, 0x7d,
	0xe8, 0x54, 0x3a, 0xee, 0xbc, 0x89, 0x23, 0x68, 0x8f, 0x7e, 0x50, 0x2f, 0x11, 0x34, 0xa7, 0x3f,
	0x03, 0xa3, 0xd8, 0x35, 0x85, 0xde, 0xb9, 0x00, 0x25, 0xce, 0xe9, 0xc0, 0x51, 0x41, 0x93, 0x6a,
	0x0e, 0x7e, 0x69, 0x00, 0xe3, 0xa2, 0x0d, 0x9d, 0x43, 0x33, 0x5f, 0x5a, 0x84, 0xaa, 0x7c, 0xe9,
	0xcb, 0x61, 0x9f, 0x54, 0x6b, 0x9b, 0xeb, 0xed, 0xec, 0xa1, 0x73, 0x68, 0xa8, 0xed, 0x42, 0x56,
	0x15, 0x58, 0xdd, 0x6c, 0xfb, 0x78, 0xcb, 0x49, 0xd1, 0xff, 0x16, 0x8c, 0x62, 0x2e, 0x68, 0x4d,
	0x6c, 0x73, 0xc0, 0xf6, 0xa3, 0x1d, 0xa7, 0x39, 0xd7, 0xe0, 0x33, 0x98, 0xe5, 0x97, 0x65, 0x2f,
	0xdf, 0x25, 0x1c, 0x64, 0x13, 0x40, 0x76, 0xb5, 0x7f, 0x7d, 0xba, 0xf6, 0xc3, 0xad, 0x67, 0x39,
	0xf3, 0xf0, 0x14, 0x3a, 0x7e, 0xe8, 0x2e, 0xe2, 0xc8, 0x73, 0x6f, 0x3c, 0x97, 0xb2, 0x85, 0xcf,
	0xe8, 0xf0, 0xa8, 0x14, 0x9b, 0xca, 0xb7, 0x77, 0xaa, 0x5d, 0xed, 0xab, 0x47, 0xf8, 0xec, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x6c, 0x9b, 0xec, 0x62, 0x98, 0x05, 0x00, 0x00,
}
